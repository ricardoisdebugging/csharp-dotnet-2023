- 静态类型
  - 这里的静态类型，和后面说的`static`关键词不一样
  - 一些对象一旦编译，其声明时设定的类型就会确定。这些类型被称之为**静态类型**
- dynamic
  - 与静态类型相反，只有在运行时才会确定的类型就是动态类型

---

- 字符串
  - 0个或多个字符类型组成的有限序列为字符串类型
  - 逐字字符串————字符串前面用“@”符号，表示转义序列不被处理
  - 字符串插值————字符串前面用“$"符号，后面双引号中的大括号内容指向变量，其实是格式化字符串的语法糖。如果想实现大括号、那么可以再套加一层
  - 字符串格式————“{index, alignment:format}”，其中index可以在插值时直接用变量代替，alignment可选、默认右对齐（左对齐前面符号为-）、其值为格式长度，format可选
  - 同一字符串字面量只在程序集中定义一次，所有字符串变量都指向同一字面量
  - 字符串不可变————所有string类型的数据，都是不可变的、或者说不可修改的，只能为其重新赋值，让它引用内存中的地址
    - 如果有大量字符串需要修改，则应该使用StringBuilder
  - 换行————为了消除平台不一致，建议使用System.Environment.NewLine

---
- null
  -  可以赋值给引用类型、指针类型以及可空值类型
    -  作为引用类型，字符串可以接受null作为字面量使用，代表“无”。将null设置给字符串不等于将字符串设置为""。例如，无号码可以表示为号码为""，号码未知则可以表示为null 

---
- 可空修饰符（详细信息来自于深入解析C#）


---
- 数组 （糅合了图解C#的内容）
  - 在声明的同时赋值，赋值可以不用`new`关键词。如果声明之后再赋值，就需要使用`new`关键词
  - 使用`new`之后，就会自动为数组元素初始化（基于默认值）
  - `[]`既是数组访问符，也是数组长度限制符
  - 实例化其实有三个部分：
    - 数组第一个元素位置的引用、在栈里
    - 数组全部元素位置的引用以及方法，在堆里
    - 全部元素，在堆里
  - 寻找数组`array[i]`的数据，分成三步
    1. 在栈里找到数组初始引用位置
    2. 根据`i`的值，在堆里找到对应元素数据引用的位置（初始引用位置顺序推导）
    3. 根据`i`元素数据引用的位置，在堆里找到对应元素的数据
    <br>以上针对引用类型组成的数组。如果是值类型组成的数组，则没有第三步————顺序找到的位置存放的就是元素数据
  - 长度不可更改————由于要顺序查找元素，所以长度要稳定
  - 数组元素的类型统一为一种，声明、编译之后不可更改————由于不同类型的占位大小不同，无法顺序找到元素
  - 对于复制（或称拷贝），也完全看数组组成元素是值类型还是引用类型
    - 若是值类型，则拷贝（默认方法`clone()`是浅拷贝）会在堆里复制一个数组对象，里面保留原数组对应元素的数据值
    - 若是引用类型，则拷贝（会在堆里复制一个数组对象，里面保留原数组对应元素的引用位置，仍然会和原来的数组关联